# 信号

```
// 查看信号
kill -l

// 信号的含义和默认处理方式：
man 7 signal
Signal     Value     Action   Comment
──────────────────────────────────────────────────────────────────────
SIGHUP        1       Term    Hangup detected on controlling terminal
                              or death of controlling process
SIGINT        2       Term    Interrupt from keyboard
SIGQUIT       3       Core    Quit from keyboard
SIGILL        4       Core    Illegal Instruction


SIGABRT       6       Core    Abort signal from abort(3)
SIGFPE        8       Core    Floating point exception
SIGKILL       9       Term    Kill signal
SIGSEGV      11       Core    Invalid memory reference
SIGPIPE      13       Term    Broken pipe: write to pipe with no
                              readers
SIGALRM      14       Term    Timer signal from alarm(2)
SIGTERM      15       Term    Termination signal
SIGUSR1   30,10,16    Term    User-defined signal 1
SIGUSR2   31,12,17    Term    User-defined signal 2
……
```

## 信号捕捉(signal和sigaction)

![image](https://piachh.cn/show?pic=pics/signal_syscall.png)

- 都是glibc提供的函数；
- 更推荐sigaction，用户能自定义更多；

### signal

```
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

为什么更推荐用sigaction？因为signal的实现，为你自作主张设置了一些东西：

```
#  define signal __sysv_signal
__sighandler_t
__sysv_signal (int sig, __sighandler_t handler)
{
  struct sigaction act, oact;
......
  act.sa_handler = handler;
  __sigemptyset (&act.sa_mask); //清空mask，使得信号处理函数能被其它信号中断
  
  // SA_ONESHOT 设置的处理函数仅起作用一次
  // SA_NOMASK 处理函数能被其它信号中断，这需要用户写好处理函数，比如避免死锁等问题（可以在处理函数中先暂时屏蔽本信号，等处理完了再打开）
  // SA_INTERRUPT 当信号来的时候，某个系统调用被中断了，那么信号处理结束后，该系统调用不会继续，而是直接返回错误码-EINTR
  // SA_RESTART 表示重新执行被中断的系统调用
  act.sa_flags = SA_ONESHOT | SA_NOMASK | SA_INTERRUPT;
  act.sa_flags &= ~SA_RESTART; //不重新执行系统调用
  
  // 后面的流程同sigaction
  if (__sigaction (sig, &act, &oact) < 0)
    return SIG_ERR;
  return oact.sa_handler;
}
weak_alias (__sysv_signal, sysv_signal)
```

### sigaction

```
int sigaction(int signum, const struct sigaction *act,
                     struct sigaction *oldact);
struct sigaction {
	__sighandler_t sa_handler;
	unsigned long sa_flags;
	__sigrestore_t sa_restorer;
	sigset_t sa_mask;		/* mask last for extensibility */
};

// 调用链
__sigaciton -> __libc_sigaction -> rt_sigaction -> do_sigaction

// 在rt_sigaction中，将用户态的结构struct sigaction拷贝到内核态的k_sigaction，然后调用do_sigaction()

int do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)
{
	struct task_struct *p = current, *t;
	struct k_sigaction *k;
	sigset_t mask;
......

    // task_struct中的sighand
    // action是一个信号处理函数数组，下标是信号
	k = &p->sighand->action[sig-1];


	spin_lock_irq(&p->sighand->siglock);
	if (oact)
		*oact = *k;


	if (act) {
	    // SIGKILL和SIGSTOP是2个无法被捕捉和忽略的信号!
		sigdelsetmask(&act->sa.sa_mask,
			      sigmask(SIGKILL) | sigmask(SIGSTOP));
		*k = *act; // 将我们的处理函数设置进去
......
	}


	spin_unlock_irq(&p->sighand->siglock);
	return 0;
}

```





# 软中断

## linux中断处理的两个阶段

### 上半部

**上半部**直接处理硬件请求，也就是我们常说的**硬中断**，特点是快速执行(在中断禁止模式下运行)，会打断CPU正在执行的任务。

以网卡接收数据为例，在上半部完成了：
1. 通过硬件中断的方式，通知内核有新的数据到了；
2. 把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了）；
3. 发送一个软中断信号，通知下半部做进一步的处理。

### 下半部

**下半部**由内核触发，也就是我们常说的软中断，特点是延迟执行（在**内核线程**中运行），用来延迟处理上半部未完成的工作。

> 每个 CPU 都对应一个软中断内核线程，名字为 “ksoftirqd/CPU编号”，比如说， 0 号CPU对应的软中断内核线程的名字就是 ksoftirqd/0。

网卡接收数据的下半部：
从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。

## 软中断的定义

软中断包括：
1. 硬件设备中断处理程序的下半部；
2. 一些内核自定义的事件，比如内核调度和RCU锁等。

> RCU(Read-Copy Update)，顾名思义就是读-拷贝修改，它是基于其原理命名的。对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作。

## 查看软中断和内核线程

```
#  /proc/softirqs 文件的内容，可以看到各种类型软中断在不同CPU上的系统运行以来的累积运行次数
# 不同类型的软中断次数在不同核上应该差不多
$ cat /proc/softirqs
                    CPU0       
          HI:          1
       TIMER:  590303880
      NET_TX:          0
      NET_RX:   77180188
       BLOCK:          0
BLOCK_IOPOLL:          0
     TASKLET:         25
       SCHED:          0
     HRTIMER:          0
         RCU:  331450756

# 通过watch命令来看中断次数的变化
$ watch -d cat /proc/softirqs
```

```
# 查看软中断内核线程
# ps的输出中，名字括在中括号里的，一般都是内核线程。
$ ps aux | grep softirq
root         3  0.0  0.0      0     0 ?        S     2018   0:35 [ksoftirqd/0]
```

### sar查看网络收发统计数据

```
# -n DEV 表示显示网络收发的报告，间隔1秒输出一组数据
$ sar -n DEV 1
15:03:46        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
15:03:47         eth0  12607.00   6304.00    664.86    358.11      0.00      0.00      0.00      0.01
15:03:47      docker0   6302.00  12604.00    270.79    664.66      0.00      0.00      0.00      0.00
15:03:47           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
15:03:47    veth9f6bbcd   6302.00  12604.00    356.95    664.66      0.00      0.00      0.00      0.05
```
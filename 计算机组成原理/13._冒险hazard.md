# 结构冒险(structural hazard)

> 硬件资源竞争。

对译码器的竞争：

![image](https://piachh.cn/show?pic=pics/hazard_struct.jpeg)

现代CPU(冯诺依曼体系结构)解决方案：混合架构(将CPU内部的高速缓存分为**指令缓存**和**数据缓存**)。

![image](https://piachh.cn/show?pic=pics/hazard_struct_sl.jpeg)

# 数据冒险(data hazard)

> 指令之间有数据的依赖。

1. 先写后读(RAW)：数据依赖，data dependency
2. 先读后写(WAR)：反依赖，anti-dependency
3. 写后再写(WAW)：输出依赖，output dependency

解决方案：

## NOP等待

将受依赖的指令执行向后推迟：

![image](https://piachh.cn/show?pic=pics/hazard_data_sl_nop.jpeg)

缺点：牺牲了CPU性能，最坏情况使CPU退化为单指令CPU。

## 操作数前推(operand forwarding)

> 也叫**操作数旁路(operand bypassing)**

通过硬件层面制造一条旁路，让一条指令的计算结果，直接传输给下一条指令。

省去了中介寄存器的读和写，有助于后一条指令较少甚至消除NOP。

```
// 2条数据依赖指令
add $t0, $s2,$s1    // t0 = s1+s2
add $s2, $s1,$t0    // s2 = s1+t0
```
仅使用nop的方案：

![image](https://piachh.cn/show?pic=pics/hazard_data_sl_without_forward.jpeg)

使用操作数前推后：

![image](https://piachh.cn/show?pic=pics/hazard_data_sl_forward.jpeg)

## 乱序执行(OoOE)

```
a = b + c
d = a * e
x = y * z
// 最后一条指令不依赖于前面的指令，可以先执行
```

![image](https://piachh.cn/show?pic=pics/hazard_data_sl_oooe.jpeg)

乱序执行的实现，基于“执行池”：

![image](https://piachh.cn/show?pic=pics/hazard_data_sl_oooe_pool.jpeg)

- 当指令不存在依赖缺失的时候，就可以放到执行池等待被执行；
- 执行完成后，结果被放到重排序缓冲区，重新排序后再提交，以保障strong memory model。

# 控制冒险(control hazard)